# -*- coding: utf-8 -*-
"""Resource module for BPMN Simulator

This module provide a shared resource system feature for BPMN Simulator
The resources are divided into different resource groups by their specification, such as working calendar.


Example
-------

    from src.BPMNGenerator import Resource


Notes
-----


"""

import simpy
import uuid


class BasicResource(object):
    """
    Resource class for creating resource object used in simulator.
    Resource can be set as preemptive, if so, other request for this resource with higher
    or equal priority may interrupt the current possession of this resource.
    """

    def __init__(self, env: simpy.Environment, res_name: str, capacity=1, preemptive=False):
        self.env = env
        self.name = res_name
        self.id = uuid.uuid4().hex[:5]
        self.preemptive = preemptive
        self.capacity = capacity
        self.granted = None
        self.req = None
        self.granted_time = None

        if self.preemptive:
            self.res = simpy.PreemptiveResource(self.env, capacity=self.capacity)
        else:
            self.res = simpy.Resource(self.env, capacity=self.capacity)

    def get_request(self, priority=1, preempt=False) -> list:
        """
        Set the generation parameter for the generator

        Parameters
        ----------
        priority
           request priority when request for a preemptive resource, higher value means lower priority. Default 1.

        Returns
        -------
        list
            request event
        """
        if self.preemptive:
            req = self.res.request(priority, preempt=preempt)
        else:
            req = self.res.request()
        return [self.res, req]

    def request_resource(self, req: simpy.Event, res_in_use: list):
        """

        Parameters
        ----------
        req

        Returns
        -------

        """
        try:
            yield req
        except simpy.Interrupt as interrupt:
            #print("req inter: ", req, "  triggered: ", req.triggered, " processed: ", req.processed)
            if not req.triggered:
                req.cancel()
                return
        while req.triggered and not req.processed:
            try:
                yield req
            except simpy.Interrupt as interrupt:
                print("req inter again: ", req, "  triggered: ", req.triggered, " processed: ", req.processed)
            self.res.release(req)
            return
        res_in_use.append([self.res, req, self.env.now, self.name, self])


    def release(self, req: simpy.Event) -> None:
        """
        Set the generation parameter for the generator

        Parameters
        ----------
        req
            request event generated by requesting the resource

        Returns
        -------
            None
        """
        self.res.release(req)

    def set_env(self, env):
        self.env = env
        if self.preemptive:
            self.res = simpy.PreemptiveResource(self.env, capacity=self.capacity)
        else:
            self.res = simpy.Resource(self.env, capacity=self.capacity)


class BasicResourceGroup(object):
    """
    Resource group class for creating resource group object, which contains a list of resources in a specific type.
    Call generate_resource to get a instance of corresponding resource
    """

    def __init__(self, env: simpy.Environment, group_name: str, capacity=1, preemptive=False,
                 starting_prio=1000, incre_prio=0.1):
        self.env = env
        self.name = group_name
        self.id = uuid.uuid4().hex[:5]
        self.resource_pool = []
        self.preemptive = preemptive
        self.capacity = capacity
        self.starting_prio = starting_prio
        self.incre_prio = incre_prio
        self.release_time = 0
        self.captured = False

    def initialize_group(self):
        pass

    def add_resource(self, res) -> None:
        """
        Generate a resource instance and add it the group resource pool

        Parameters
        ----------
        res

        Returns
        -------
        """
        self.resource_pool.append(res)

    def terminate_resource(self, res) -> None:
        """
        Remove the resource instance from the group resource pool

        Parameters
        ----------
        res
            resource instance that expired during simulation

        Returns
        -------
            None
        """
        self.resource_pool.remove(res)

    def get_resources(self):
        return self.resource_pool

    def set_env(self, env):
        self.env = env
        for resource in self.resource_pool:
            resource.set_env(env)

    def request_resource_group(self, finished, res_group_in_use: list, granted: simpy.Event,
                               owner: simpy.Process, resource_pool, priority=1):

        res_in_use = []
        prio = priority

        if len(resource_pool) == 0:
            active_resource_pool = self.resource_pool
        else:
            active_resource_pool = resource_pool

        while len(res_in_use) == 0:
            selective_req_events = []
            pool_temp = []
            req_process_list = []
            start_captured = False
            start_time = self.env.now
            if self.captured:
                start_captured = True
            if prio <= 0:
                print("resource prio error: prio out of bound")
                raise simpy.exceptions.SimPyException()
            for selective_res in active_resource_pool:
                res_req = selective_res.get_request(priority=prio)
                pool_temp.append(selective_res)
                selective_req_events.append(res_req[1])
                req_process = self.env.process(selective_res.request_resource(res_req[1],
                                                                              res_in_use))
                req_process_list.append(req_process)
            try:
                yield simpy.events.AnyOf(self.env, selective_req_events)
                if start_captured:
                    start_time = self.release_time
            except simpy.Interrupt as interrupt:
                prio = prio - self.incre_prio
                for res in res_in_use:
                    res[0].release(res[1])
            finally:
                for req_pro in req_process_list:
                    if req_pro.is_alive:
                        req_pro.interrupt()


        try:
            if len(res_in_use) > 1:
                for extra_res in res_in_use[1:]:
                    extra_res[0].release(extra_res[1])
            pool_temp.remove(res_in_use[0][-1])
            pool_temp.insert(0, res_in_use[0][-1])
            wait_time = self.env.now - start_time
            res_in_use[0].insert(-1, wait_time)
            res_group_in_use.append(res_in_use[0])
            resource_pool.clear()
            resource_pool.extend(pool_temp)
            granted.succeed()
            yield finished
        except simpy.Interrupt as interrupt:
            if owner.is_alive:
                owner.interrupt(interrupt.cause)
        finally:
            for res in res_in_use:
                res[0].release(res[1])


class CalendarResourceGroup(BasicResourceGroup):
    """
    Calender resource group class for creating working timetable object,
    which contains a list of resources operating within a specific timetable.
    Call generate_resource to get a instance of corresponding resource
    """

    def __init__(self, env, group_name, time_table, starting_prio=1, incre_prio=0.1):
        super().__init__(env, group_name, starting_prio=starting_prio,
                         incre_prio=incre_prio)
        self.time_table = time_table
        self.enable = True
        self.env.process(self.rotate())

    def start_rotate(self):
        self.env.process(self.rotate())

    def set_env(self, env):
        self.env = env
        for resource in self.resource_pool:
            resource.set_env(env)

    def set_time_table(self, timetable: list) -> None:
        """
        Generate a resource instance and add it the group resource pool

        Parameters
        ----------
        timetable
        list of time periods that indicates available and unavailable time

        Returns
        -------
        None
        """
        self.time_table = timetable

    def generate_resource(self, name) -> BasicResource:
        """
        Generate a resource instance and add it the group resource pool

        Parameters
        ----------
        name
            name of the generated resource in str

        Returns
        -------
        BasicResource
            resource instance
        """
        res = BasicResource(self.env, name, capacity=1, preemptive=True)
        self.resource_pool.append(res)
        self.enable = True
        return res

    def terminate_resource(self, res):
        """
        Remove the resource instance from the group resource pool

        Parameters
        ----------
        res
            resource instance that expired during simulation

        Returns
        -------
        None
        """
        self.resource_pool.remove(res)
        if len(self.resource_pool) == 0:
            self.enable = False

    def rotate(self) -> None:
        """
        Rotate the state of available/unavailable working time, when a resource become unavailable
        the process requesting it will be interrupted

        Parameters
        ----------

        Returns
        -------
        None
        """
        while self.enable and (len(self.resource_pool) > 0):
            i = 0
            for time_stamp in self.time_table:
                if time_stamp > 0:
                    if i % 2 == 0:
                        if len(self.resource_pool) > 0:
                            #print("rotate capture at: ", self.env.now)
                            self.captured = True
                            req_event = []
                            request_list = []
                            for single_resource in self.resource_pool:
                                res_req = single_resource.get_request(priority=0, preempt=True)

                                request_list.append(res_req)
                                req_event.append(res_req[1])
                            yield simpy.events.AllOf(self.env, req_event)
                            try:
                                yield self.env.timeout(time_stamp)
                                self.captured = False
                                for single_request in request_list:
                                    single_request[0].release(single_request[1])

                                self.release_time = self.env.now
                                #print("rotate release at: ", self.env.now)
                            except simpy.Interrupt as interrupt:
                                print("Calendar error at: ", self.env.now)
                            # print("rotate release at: ", self.env.now)


                    else:
                        yield self.env.timeout(time_stamp)
                i = i + 1